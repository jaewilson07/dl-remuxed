"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/95_DomoAuth.ipynb.

# %% auto 0
__all__ = ['DomoAuth', 'test_is_full_auth', 'DomoTokenAuth', 'DomoDeveloperAuth', 'DomoJupyterAuth', 'DomoJupyterFullAuth',
           'DomoJupyterTokenAuth', 'test_is_jupyter_auth']

# %% ../../nbs/client/95_DomoAuth.ipynb 3
from domolibrary.routes.auth import (
    AuthError,
    AccountLockedError,
    InvalidAuthTypeError,
    InvalidCredentialsError,
    InvalidInstanceError,
    NoAccessTokenReturned,
)

# %% ../../nbs/client/95_DomoAuth.ipynb 4
from dataclasses import dataclass, field
from typing import Optional, Union


from abc import ABC, abstractmethod
import httpx

import domolibrary.client.Logger as lg

import domolibrary.routes.auth as auth_routes

# %% ../../nbs/client/95_DomoAuth.ipynb 8
# Custom exception placeholder


class _DomoAuth_Required(ABC):
    def __init__(self, domo_instance: str, **kwargs):
        if not domo_instance:
            raise InvalidInstanceError(
                "Domo instance is required. Example: 'mycompany.domo.com' or 'mycompany'"
            )
        self.domo_instance = domo_instance

    @property
    def url_manual_login(self) -> str:
        return f"https://{self.domo_instance}.domo.com/auth/index?domoManualLogin=true"


class _DomoAuth_Optional(ABC):
    """Abstract DomoAuth class."""

    def __init__(
        self,
        domo_instance: str,
        token_name: Optional[str] = None,
        token: Optional[str] = None,
        user_id: Optional[str] = None,
        is_valid_token: bool = False,
        **kwargs,
    ):
        self.domo_instance = domo_instance
        self.token_name = token_name
        self.token = token
        self.user_id = user_id
        self.is_valid_token = is_valid_token

        self._set_token_name()

        if not self.domo_instance:
            raise InvalidInstanceError(
                "Domo instance is required. Example: 'mycompany.domo.com' or 'mycompany'"
            )

    def _set_token_name(self):
        if not self.token_name:
            self.token_name = self.domo_instance

    @property
    @abstractmethod
    def auth_header(self) -> dict:
        raise NotImplementedError("Subclasses must implement auth_header property.")

    async def who_am_i(
        self,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop: int = 2,
    ):
        """Perform an API call to identify the user associated with the token."""
        res = await auth_routes.who_am_i(
            auth=self,
            parent_class=self.__class__.__name__,
            session=session,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if res.is_success:
            self.is_valid_token = True

        self.user_id = res.response.get("id")
        return res

    async def elevate_otp(
        self,
        one_time_password: str,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop: int = 2,
    ):
        """Elevate the authentication to include OTP (One-Time Password) if required."""
        res = await auth_routes.elevate_user_otp(
            auth=self,
            debug_api=debug_api,
            session=session,
            one_time_password=one_time_password,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )
        return res

    @abstractmethod
    async def get_auth_token(
        self,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop: int = 2,
    ) -> Union[str, None]:
        """Placeholder method"""
        raise NotImplementedError("Subclasses must implement get_auth_token method.")

    async def print_is_token(
        self,
        debug_api: bool = False,
        token_name: Optional[str] = None,
        session: Optional[httpx.AsyncClient] = None,
    ) -> bool:
        """Print token status and return True if token is valid, otherwise False."""
        self.token_name = token_name or self.token_name

        if not self.token:
            await self.get_auth_token(debug_api=debug_api, session=session)

        if not self.is_valid_token:
            await self.who_am_i(session=session, debug_api=debug_api)

        if not self.is_valid_token:
            print(
                f"🚧 failed to retrieve {self.token_name} token from {self.domo_instance}"
            )
            return False

        print(f"🎉 {self.token_name} token retrieved from {self.domo_instance} ⚙️")
        return True

# %% ../../nbs/client/95_DomoAuth.ipynb 9
@dataclass
class DomoAuth(_DomoAuth_Optional, _DomoAuth_Required):
    """Concrete combined DomoAuth base class."""


# %% ../../nbs/client/95_DomoAuth.ipynb 12
class _DomoFullAuth_Required(_DomoAuth_Required, _DomoAuth_Optional):
    """Mixin for required parameters for DomoFullAuth"""

    def __init__(self, domo_username: str, domo_password: str, domo_instance: str, **kwargs):
        if not domo_username:
            raise InvalidCredentialsError("Domo username is required.")
        if not domo_password:
            raise InvalidCredentialsError("Domo password is required.")

        if not domo_instance:
            raise InvalidInstanceError( "Domo instance is required." )

        self.domo_username = domo_username
        self.domo_password = domo_password

        super().__init__(domo_instance=domo_instance, **kwargs)

    @property
    def auth_header(self) -> dict:
        """Generate the full authentication header specific to product APIs."""
        return {"x-domo-authentication": self.token} if self.token else {}

    async def get_auth_token(
        self,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop: int = 2,
        return_raw: bool = False,
    ) -> str:
        """Retrieve the authentication token from product APIs using the provided credentials."""
        res = await auth_routes.get_full_auth(
            auth=None,
            domo_instance=self.domo_instance,
            domo_username=self.domo_username,
            domo_password=self.domo_password,
            session=session,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if return_raw:
            return res

        self.is_valid_token = True
        self.token = str(res.response.get("sessionToken"))
        self.token_name = self.token_name or "full_auth"

        return self.token


@dataclass
class DomoFullAuth(
    _DomoFullAuth_Required,
    
):
    domo_instance: str
    domo_username: str
    domo_password: str = field(repr=False)
    token_name: Optional[str] = None
    token: Optional[str] = field(default=None, repr=False)
    user_id: Optional[str] = None
    is_valid_token: bool = False

    def __post_init__(self):
        # Initialize mixins explicitly
        super().__init__(**self.__dict__)

# %% ../../nbs/client/95_DomoAuth.ipynb 17
def test_is_full_auth(
    auth, function_name=None, num_stacks_to_drop=1  # pass q for route pass 2 for class
):
    """Test that the provided object is a DomoFullAuth instance."""
    tb = lg.get_traceback(num_stacks_to_drop=num_stacks_to_drop)

    function_name = function_name or tb.function_name

    if auth.__class__.__name__ != "DomoFullAuth":
        raise InvalidAuthTypeError(
            function_name=function_name,
            domo_instance=auth.domo_instance,
            required_auth_type=DomoFullAuth,
        )

# %% ../../nbs/client/95_DomoAuth.ipynb 19
class _DomoTokenAuth_Required(_DomoAuth_Required, _DomoAuth_Optional):
    def __init__(self, domo_access_token: str, domo_instance: str, **kwargs):
        if not domo_access_token:
            raise InvalidCredentialsError("Domo access token is required.")
        self.domo_access_token = domo_access_token
        
        super().__init__(domo_instance=domo_instance,  **kwargs)

    @property
    def auth_header(self) -> dict:
        """Generate the authentication header for access token based authentication."""
        return {"x-domo-developer-token": self.token or self.domo_access_token}

    async def get_auth_token(
        self,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop=2,
        token_name=None,
    ) -> str:
        """Retrieve the access token, updating internal attributes as necessary."""

        if not self.user_id:
            await self.who_am_i(
                session=session,
                debug_api=debug_api,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
            )

        self.token = self.domo_access_token
        self.is_valid_token = True

        if token_name:
            self.token_name = token_name

        return self.token

# %% ../../nbs/client/95_DomoAuth.ipynb 20
@dataclass
class DomoTokenAuth(_DomoTokenAuth_Required):
    domo_access_token: str = field(repr=False)
    domo_instance: str

    token_name: Optional[str] = None
    token: Optional[str] = field(default=None, repr=False)
    user_id: Optional[str] = None
    is_valid_token: bool = False
    """
    use for access_token authentication.
    Tokens are generated in domo > admin > access token
    Necessary in cases where direct sign on is not permitted
    """

    def __post_init__(self):
        
        self.token = self.domo_access_token

        if not self.token:
            raise InvalidCredentialsError("Domo access token is required.")

        super().__init__(**self.__dict__)

# %% ../../nbs/client/95_DomoAuth.ipynb 26
@dataclass
class DomoDeveloperAuth(_DomoAuth_Optional, _DomoAuth_Required):
    domo_client_id: str
    domo_client_secret: str = field(repr=False)
    domo_instance: str

    token_name: Optional[str] = None
    token: Optional[str] = field(default=None, repr=False)
    user_id: Optional[str] = None
    is_valid_token: bool = False
    """
    use for access_token authentication.
    Tokens are generated in domo > admin > access token
    Necessary in cases where direct sign on is not permitted
    """

    def __post_init__(self):

        super().__init__(**self.__dict__)

    @property
    def auth_header(self) -> dict:
        """Generate the authentication header for developer token authentication."""
        return {"Authorization": "bearer " + self.token}

    async def get_auth_token(
        self,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop=2,
    ) -> str:
        """Retrieve the developer token using client credentials and update internal attributes."""

        res = await auth_routes.get_developer_auth(
            auth=None,
            domo_client_id=self.domo_client_id,
            domo_client_secret=self.domo_client_secret,
            session=session,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
        )

        if res.is_success:
            self.is_valid_token = True

        self.token = str(res.response.get("access_token"))
        self.user_id = res.response.get("userId")
        self.domo_instance = res.response.get("domain")

        self.token_name = self.token_name or "developer_auth"

        return self.token

# %% ../../nbs/client/95_DomoAuth.ipynb 30
class _DomoJupyter_Required:
    """Required parameters and setup for Domo Jupyter authentication."""

    def __init__(
        self,
        jupyter_token: str = None,
        service_location: str = None,
        service_prefix: str = None,
        **kwargs,
    ):

        # Initialize fields, prompting if not provided
        self.jupyter_token = jupyter_token or input(
            "jupyter token: # retrieve this by monitoring Domo Jupyter network traffic. It is the Authorization header\n> "
        )
        self.service_location = service_location or input(
            "service_location: # retrieve from Domo Jupyter environment\n> "
        )
        self.service_prefix = service_prefix or input(
            "service_prefix: # retrieve from Domo Jupyter environment\n> "
        )

        self._test_prereq()

    # --- Methods ---
    def get_jupyter_token_flow(self):
        """Stub method for initiating a Jupyter token retrieval flow."""
        print("hello world, I am a jupyter_token")

    def _test_prereq(self):
        """Validate that required attributes are present."""
        missing = []
        if not self.jupyter_token:
            missing.append("jupyter_token")
        if not self.service_location:
            missing.append("service_location")
        if not self.service_prefix:
            missing.append("service_prefix")

        if missing:
            raise ValueError(f"DomoJupyterAuth objects must have: {', '.join(missing)}")

# %% ../../nbs/client/95_DomoAuth.ipynb 31
@dataclass
class DomoJupyterAuth(_DomoAuth_Optional, _DomoJupyter_Required, _DomoAuth_Required):
    """base class"""

# %% ../../nbs/client/95_DomoAuth.ipynb 33
@dataclass
class DomoJupyterFullAuth(
    _DomoJupyter_Required,
    _DomoFullAuth_Required,
):
    jupyter_token: str = field(repr=False)
    service_location: str
    service_prefix: str

    domo_instance: str
    domo_username: str
    domo_password: str = field(repr=False)

    token_name: Optional[str] = None
    token: Optional[str] = field(default=None, repr=False)
    user_id: Optional[str] = None
    is_valid_token: bool = False

    def __post_init__(self):
        # Initialize mixins explicitly
        super().__init__(**self.__dict__)

    @property
    def auth_header(self) -> dict:
        return {
            **super().auth_header,
            "authorization": f"Token {self.jupyter_token}",
        }

    @classmethod
    def convert_auth(
        cls, auth: DomoFullAuth, jupyter_token, service_location, service_prefix
    ):
        """converts DomoFullAuth to DomoJupyterFullAuth
        i.e. adds DomoJupyter specific auth fields
        eventually can add DomoJupyter specific auth flow for generating auth token
        """
        return cls(
            domo_instance=auth.domo_instance,
            domo_username=auth.domo_username,
            domo_password=auth.domo_password,
            jupyter_token=jupyter_token,
            service_location=service_location,
            service_prefix=service_prefix,
            token_name=auth.token_name,
            token=auth.token,
            user_id=auth.user_id,
            is_valid_token=auth.is_valid_token,
        )

# %% ../../nbs/client/95_DomoAuth.ipynb 37
@dataclass
class DomoJupyterTokenAuth(
    _DomoJupyter_Required,
    _DomoTokenAuth_Required,
):
    jupyter_token: str = field(repr=False)
    service_location: str
    service_prefix: str

    domo_instance: str

    domo_access_token: str = field(repr=False)

    token_name: Optional[str] = None
    token: Optional[str] = field(default=None, repr=False)
    user_id: Optional[str] = None
    is_valid_token: bool = False

    def __post_init__(self):
        super().__init__(**self.__dict__)

    @property
    def auth_header(self) -> dict:
        return {
            **super().auth_header,
            "authorization": f"Token {self.jupyter_token}",
        }

    @classmethod
    def convert_auth(
        cls, auth: DomoTokenAuth, jupyter_token, service_location, service_prefix
    ):
        """converts DomoTokenAuth to DomoJupyterTokenAuth
        i.e. adds DomoJupyter specific auth fields
        eventually can add DomoJupyter specific auth flow for generating auth token
        """
        return cls(
            domo_instance=auth.domo_instance,
            domo_access_token=auth.domo_access_token,
            jupyter_token=jupyter_token,
            service_location=service_location,
            service_prefix=service_prefix,
            token_name=auth.token_name,
            token=auth.token,
            user_id=auth.user_id,
            is_valid_token=auth.is_valid_token,
        )

# %% ../../nbs/client/95_DomoAuth.ipynb 41
def test_is_jupyter_auth(
    auth: DomoJupyterAuth,
    function_name=None,
    required_auth_type_ls=[DomoJupyterFullAuth, DomoJupyterTokenAuth],
):
    """Test that the provided object is a valid Jupyter authentication instance."""
    tb = lg.get_traceback()

    if auth.__class__.__name__ not in [
        auth_type.__name__ for auth_type in required_auth_type_ls
    ]:
        raise InvalidAuthTypeError(
            function_name=tb.function_name,
            domo_instance=auth.domo_instance,
            required_auth_type_ls=required_auth_type_ls,
        )
