# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoUser.ipynb.

# %% auto 0
__all__ = ['domo_default_img', 'CreateUser_MissingRole', 'DownloadAvatar_NoAvatarKey', 'DomoUser', 'DomoUsers',
           'DomoUser_NoSearch']

# %% ../../nbs/classes/50_DomoUser.ipynb 3
from domolibrary.routes.user import (
    UserProperty,
    UserProperty_Type,
    GetUser_Error,
    SearchUser_NoResults,
    User_CrudError,
    ResetPassword_PasswordUsed,
    DeleteUser_Error,
    DownloadAvatar_Error,
    UserProperty_Type
)

from ..client.ResponseGetData import ResponseGetData

from ..routes.instance_config_sso import (SSO_AddUserDirectSignonError)
from ..utils.Image import Image, are_same_image

# %% ../../nbs/classes/50_DomoUser.ipynb 4
import datetime as dt
from dataclasses import dataclass, field
from typing import Optional, List, Any, Union
import httpx

from nbdev.showdoc import patch_to
import asyncio

import domolibrary.utils.DictDot as util_dd
from domolibrary.utils.convert import (test_valid_email, convert_epoch_millisecond_to_datetime)

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.Logger as lc
import domolibrary.client.DomoError as dmde
import domolibrary.routes.user as user_routes
import domolibrary.routes.instance_config_sso as sso_routes

# %% ../../nbs/classes/50_DomoUser.ipynb 8
class CreateUser_MissingRole(dmde.DomoError):
    def __init__(self, domo_instance, email_address):
        super().__init__(
            domo_instance=domo_instance,
            message=f"error creating user {email_address} missing role_id",
        )


class DownloadAvatar_NoAvatarKey(dmde.DomoError):
    def __init__(
        self,
        domo_instance,
        user_id,
    ):
        super().__init__(
            domo_instance,
            message=f"This profile {user_id} doesn't have an avatar uploaded - unable to download",
        )

# %% ../../nbs/classes/50_DomoUser.ipynb 10
@dataclass
class DomoUser:
    """a class for interacting with a Domo User"""

    auth: dmda.DomoAuth = field(repr=False)

    id: str
    display_name: str = None
    email_address: str = None
    role_id: str = None
    department: str = None
    title: str = None
    avatar_key: str = None
    password : str = field(repr = False, default = None)

    phone_number: str = None
    web_landing_page: str = None
    web_mobile_landing_page: str = None
    employee_id: str = None
    employee_number: str = None
    hire_date: str = None
    reports_to: str = None

    publisher_domain: str = None
    subscriber_domain: str = None
    virtual_user_id: str = None

    created_dt : dt.datetime = None
    last_activity_dt: dt.datetime = None

    custom_attributes: dict = field(default_factory=dict)

    role: Any = None  # DomoRole
    domo_api_clients : List[Any] = None
    domo_access_tokens : List[Any] = None


    def __post_init__(self):
        self.id = str(self.id)

    def __eq__(self, other):
        if self.__class__.__name__ != other.__class__.__name__:
            return False

        return self.id == other.id

    @classmethod
    def _from_search_json(cls, auth, user_obj):
        user_dd = util_dd.DictDot(user_obj)

        return cls(
            auth=auth,
            id=str(user_dd.id or user_dd.userId),
            display_name=user_dd.displayName,
            title=user_dd.title,
            department=user_dd.department,
            email_address=user_dd.emailAddress or user_dd.email,
            role_id=user_dd.roleId,
            avatar_key=user_dd.avatarKey,
            phone_number=user_dd.phoneNumber,
            web_landing_page=user_dd.webLandingPage,
            web_mobile_landing_page=user_dd.webMobileLandingPage,
            employee_id=user_dd.employeeId,
            employee_number=user_dd.employeeNumber,
            hire_date=user_dd.hireDate,
            reports_to=user_dd.reportsTo,
            created_dt = convert_epoch_millisecond_to_datetime(user_dd.created),
            last_activity_dt = convert_epoch_millisecond_to_datetime(user_dd.lastActivity)
        )

    @classmethod
    def _from_virtual_json(cls, auth, user_obj):
        user_dd = util_dd.DictDot(user_obj)

        return cls(
            id=user_dd.id,
            auth=auth,
            publisher_domain=user_dd.publisherDomain,
            subscriber_domain=user_dd.subscriberDomain,
            virtual_user_id=user_dd.virtualUserId,
        )

    @classmethod
    def _from_bootstrap_json(cls, auth, user_obj):
        dd = user_obj
        if isinstance(user_obj, dict):
            dd = util_dd.DictDot(user_obj)

        return cls(id=dd.id, display_name=dd.displayName, auth=auth)

# %% ../../nbs/classes/50_DomoUser.ipynb 12
@patch_to(DomoUser)
async def get_role(
    self: DomoUser,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoRole as dmr

    self.role = await dmr.DomoRole.get_by_id(
        role_id=self.role_id,
        auth=self.auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    return self.role

# %% ../../nbs/classes/50_DomoUser.ipynb 13
@patch_to(DomoUser, cls_method=True)
async def get_by_id(
    cls: DomoUser,
    user_id,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    """
    searches and returns a domo user
    will throw an error if no user returned with an option to suppress_no_results_error
    """

    res = await user_routes.get_by_id(
        auth=auth,
        user_id=user_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    domo_user = cls._from_search_json(user_obj=res.response, auth=auth)
    
    try:
        await domo_user.get_role(debug_api = debug_api, debug_num_stacks_to_drop = debug_num_stacks_to_drop, session = session)
    
    except dmde.DomoError as e:
        print(e)


    return domo_user

# %% ../../nbs/classes/50_DomoUser.ipynb 16
@patch_to(DomoUser)
async def download_avatar(
    self: DomoUser,
    pixels: int = 300,
    folder_path="./images",
    img_name=None,  # will default to user_id
    auth: dmda.DomoAuth = None,
    is_download_image: bool = True,  # option to prevent downloading the image file
    debug_api: bool = False,
    return_raw: bool = False,
):
    """downloads a user's avatar to a folder
    and returns the byte representation of the image
    """
    auth = auth or self.auth

    # if not self.avatar_key:
    #     raise DownloadAvatar_NoAvatarKey(
    #         domo_instance=auth.domo_instance, user_id=self.id
    #     )

    res = await user_routes.download_avatar(
        auth=self.auth,
        user_id=self.id,
        pixels=pixels,
        folder_path=folder_path,
        img_name=img_name,
        is_download_image=is_download_image,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    self.avatar = Image.from_bytestr(data=res.response)

    return self.avatar

    # return res.response

# %% ../../nbs/classes/50_DomoUser.ipynb 20
@patch_to(DomoUser)
async def update_properties(
    self: DomoUser,
    property_ls: List[
        UserProperty
    ],  # use the UserProperty class to define a list of user properties to update, see user route documentation to see a list of UserProperty_Types that can be updated
    return_raw: bool = False,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    res = await user_routes.update_user(
        auth=auth,
        user_id=self.id,
        user_property_ls=property_ls,
        debug_api=debug_api,
        session=session,
    )
    if return_raw:
        return res

    self = await DomoUser.get_by_id(user_id=self.id, auth=auth)

    return self


@patch_to(DomoUser)
async def set_user_landing_page(
    self: DomoUser,
    page_id: str,
    user_id: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
):
    res = await user_routes.set_user_landing_page(
        auth=auth or self.auth,
        page_id=page_id,
        user_id=self.id or user_id,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/classes/50_DomoUser.ipynb 23
@patch_to(DomoUser, cls_method= True)
async def create(
    cls,
    auth : dmda.DomoAuth,
    display_name,
    email_address,
    role_id,
    password: str = None,
    send_password_reset_email: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 2,
    session: httpx.AsyncClient = None,
):
    """class method that creates a new Domo user"""

    res = await user_routes.create_user(
        auth=auth,
        display_name=display_name,
        email_address=email_address,
        role_id=role_id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    domo_user = await DomoUser.get_by_id(
        auth=auth,
        user_id=res.response.get("id") or res.response.get("userId"),
    )

    if password:
        await domo_user.reset_password(new_password=password)

    elif send_password_reset_email:
        await domo_user.request_password_reset(
            domo_instance=auth.domo_instance, email=domo_user.email_address
        )

    return domo_user



@patch_to(DomoUser)
async def delete(
    self: DomoUser,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    parent_class=None,
):

    res = await user_routes.delete_user(
        auth=self.auth,
        user_id=self.id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    return res

# %% ../../nbs/classes/50_DomoUser.ipynb 27
@patch_to(DomoUser)
async def reset_password(
    self: DomoUser,
    new_password: str,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop: int = 2,
):
    """reset your password, will respect password restrictions set up in the Domo UI"""

    res = await user_routes.reset_password(
        auth=self.auth,
        user_id=self.id,
        new_password=new_password,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class = self.__class__.__name__
    )

    self.password = new_password

    return res


@patch_to(DomoUser, cls_method=True)
async def request_password_reset(
    cls,
    domo_instance: str,
    email: str,
    locale: str = "en-us",
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop : int = 2
):
    """request password reset email.  Note: does not require authentication."""

    return await user_routes.request_password_reset(
        domo_instance=domo_instance,
        email=email,
        locale=locale,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop = debug_num_stacks_to_drop,
        parent_class = cls.__name__
    )

# %% ../../nbs/classes/50_DomoUser.ipynb 28
@patch_to(DomoUser)
async def upload_avatar(
    self,
    avatar: Image,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    avatar.crop_square()

    res = await user_routes.upload_avatar(
        auth=self.auth,
        user_id=self.id,
        img_bytestr=avatar.to_bytes(),
        img_type=avatar.format,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        session=session,
    )

    if return_raw:
        return res

    await asyncio.sleep(2)

    return await self.download_avatar(debug_api=debug_api)

# %% ../../nbs/classes/50_DomoUser.ipynb 30
default_img_bytes = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x01,\x00\x00\x01,\x08\x06\x00\x00\x00y}\x8eu\x00\x00\x0eUIDATx\x9c\xed\xdd\xe9r\xda\xd8\x16@\xe1-\x81\x84\x18M\x02\xb1\x93T\xbf\xff\xa3\xb9\xc1\x063\nM\xe8\xe8\xfe\xe86\x95\xdc\x0c\x9d86\xe7\xec\xa3\xf5UQvuW%;\x12Z\x80&\x82\xcdf\xd3\x08\x00(\x10\xda\x1e\x00\x00~\x15\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0F\xd7\xf6\x00\xd0\xabi\x1a1\xc6\x881F\x9a\xa6\x91\xa6iDD\xc4\x18#""a\xf8\xcf\xeba\x10\x04\x12\x04\x81\x84a(a\x18J\x10\x04\xd6f\x86n\x04\x0b\xbf\xa4\xaek\xc9\xf3\\\xf2<\x97\xaa\xaa\xa4,K\xa9\xaa\xeaE\x7fV\x14E\x12\xc7\xb1DQ$I\x92H\x92$\xd2\xe9t^yb\xf8\x88`\xe1\x87\xb2,\x93\xd3\xe9$Y\x96IQ\x14\xaf\xf6\xe7VU\xf5M\xecz\xbd\x9e\xf4\xfb}\x19\x0c\x06\xd2\xef\xf7_\xed\xef\x82_\x82\xcdf\xd3\xd8\x1e\x02\xee\xa8\xaaJ\x0e\x87\x83\x1c\x8f\xc7\x17\xbf\x83\xfaSQ\x14\xc9h4\x92\xf1x,Q\x14Y\x99\x01n"X\x10\x11\x914Me\xbb\xddJ\x9e\xe7\xb6G\xf9J\x92$2\x9dNe8\x1c\xda\x1e\x05\x0e X-w8\x1cd\xbb\xddJY\x96\xb6G\xf9\xa98\x8ee:\x9d\xcax<\xb6=\n,"X-\x95\xa6\xa9\xac\xd7kk\x1f\xfb^*\x8a"\x99\xcdf\xbc\xe3j)\x82\xd52\xe7\xf3Y\x1e\x1f\x1f\xe5t:\xd9\x1e\xe5\x8f\x0c\x06\x03\xf9\xf0\xe1\x83t\xbb\x1c7j\x13\x82\xd5\x12M\xd3\xc8f\xb3\x91\xedv{9_J\xbb \x08d:\x9d\xca\xbbw\xef8\xb7\xab%\x08V\x0bTU%\xcb\xe5\xf2UOMpI\xaf\xd7\x93\xbb\xbb;\x8e(\xb6\x00\xc1\xf2\\\x9a\xa6\xf2\xf0\xf0p9\xfb\xdcWa\x18\xca\xed\xed-\xfb\xb6<G\xb0<\xb6^\xafe\xbb\xdd\xda\x1e\xe3\xaa\xa6\xd3\xa9\xccf3\xdbc\xe0\x8d\xb0\xc7\xd2CM\xd3\xc8\xc3\xc3\x83\x1c\x8fG\xdb\xa3\\\xddv\xbb\x95\xf3\xf9,\xb7\xb7\xb7\xec\xd7\xf2\x10\xc1\xf2\x8c1F\x16\x8b\x85dYf{\x14k\x8e\xc7\xa3\xd4u-\x1f?~\xbc\\\x80\r?\xb06=b\x8c\x91\xfb\xfb\xfbV\xc7\xeaY\x96er\x7f\x7f\xef\xfd\xbe\xbb\xb6!X\x9ex\x8e\x95\xafG\x02_\xa2(\n\xa2\xe5\x19\x82\xe5\x81\xa6i\xbc>m\xe1O\x14E!\xcb\xe5\xd2\x9bs\xcf\xda\x8e`y\xc0\x873\xd7\xdf\xd2\xe9t\x92\xc7\xc7G\xdbc\xe0\x15\x10,\xe5\x9e\x9e\x9e\xe4p8\xd8\x1e\xc3y\x87\xc3A\x9e\x9e\x9el\x8f\x81?D\xb0\x14\xcb\xf3\\6\x9b\x8d\xed1\xd4\xd8l6\xce\xdd>\x07\xbf\x87`)U\xd7\xb5,\x16\x0b\xdbc\xa8\xb3X,\xa4\xaek\xdbc\xe0\x85\x08\x96R\xcb\xe5\x92\r\xef\x05\xea\xba\x96\xe5ri{\x0c\xbc\x10\xc1Rh\xbf\xdfs\xae\xd5\x1f\xc8\xb2L\xf6\xfb\xbd\xed1\xf0\x02\x04K\x19c\x8c\xac\xd7k\xdbc\xa8\xb7^\xaf9?K!\x82\xa5\xccj\xb5bC{\x05\xc6\x18Y\xadV\xb6\xc7\xc0o"X\x8a\xe4y\xce)\x0c\xaf\xe8p8p\xd4P\x19\x82\xa5\x08\x1f\x05_\x1f\xcbT\x17\x82\xa5\xc4\xf3\xb7.\xe3u\xb1\\u!XJp\x82\xe8\xdba\xd9\xeaA\xb0\x14(\x8a\x82k\x05\xdf\xd0\xe9t\xe2\xc2q%\x08\x96\x02\xbb\xdd\xce\xf6\x08\xdec\x19\xeb@\xb0\x1cg\x8c\x914Mm\x8f\xe1\xbd4M9]D\x01\x82\xe586\xa4\xeb\xe0\x85A\x07\x82\xe58\xce\xbb\xba\x1e\x96\xb5\xfb\x08\x96\xc3\xea\xba\xe6\x9a\xc1+\xca\xb2\x8c\x0b\xca\x1dG\xb0\x1cF\xac\xae\x8fe\xee6\x82\xe506\x9e\xebc\x99\xbb\x8d`9\x8cs\xaf\xae\x8fe\xee6\x82\xe5\xa8\xaa\xaa\xe4|>\xdb\x1e\xa3u\xce\xe7\xb3TUe{\x0c\xfc\x00\xc1r\x14g^\xdb\xc3\xb2w\x17\xc1r\x14\xaf\xf2\xf6\xb0\xec\xddE\xb0\x1c\xc5Fc\x0f\xcb\xde]\x04\xcbQeY\xda\x1e\xa1\xb5X\xf6\xee"X\x8e\xe2U\xde\x1e\x96\xbd\xbb\x08\x96\x83\x9a\xa6\xe1\xfaA\x8b\x8c1\xd24\x8d\xed1\xf0\x1d\x04\xcbA\xc4\xca>\xd6\x81\x9b\x08\x96\x83xu\xb7\x8fu\xe0&\x82\xe5 .\xc0\xb5\x8fu\xe0&\x82\xe5 ^\xdd\xedc\x1d\xb8\x89`9(\x08\x02\xdb#\xb4\x1e\xeb\xc0M\x04\xcbAl,\xf6\xb1\x0e\xdcD\xb0\x1c\x14\x86\xac\x16\xdbX\x07nb\xad8\x88Ww\xfbX\x07n"X\x0e\xeat:\xb6Gh=\xd6\x81\x9b\x08\x96\xa3\xba\xdd\xae\xed\x11Z\x8be\xef.\x82\xe5\xa88\x8em\x8f\xd0Z,{w\x11,G\xb1\xd1\xd8\xc3\xb2w\x17\xc1rT\x14E\xb6Gh-\x96\xbd\xbb\x08\x96\xa3\xd8h\xeca\xd9\xbb\x8b`9*I\x12\x0e\xad[\x10\x04\x81$Ib{\x0c\xfc\x00\xc1r\x14\x1b\x8e\x1d\xbcP\xb8\x8d`9\xac\xdf\xef\xdb\x1e\xa1uX\xe6n#X\x0ec\xe3\xb9>\x96\xb9\xdb\x08\x96\xc3\x92$\xe1$\xc6+\xeav\xbb|\x0cw\x1c\xc1r\xdch4\xb2=Bk\xb0\xac\xddG\xb0\x1c7\x1e\x8fm\x8f\xd0\x1a,k\xf7\x11,\xc7\xc5q\xcc\x99\xd7W\xc0r\xd6\x81`)0\x99Ll\x8f\xe0=\x96\xb1\x0e\x04K\x81\xc9d\xc2\xedN\xdeP\xa7\xd3!XJ\x10,\x05\x82 \x90\xe9tj{\x0coM\xa7SN\x16U\x82`)1\x99L\xb8m\xef\x1b\x08\xc3\x90wW\x8a\xb0\x05(\x11\x86\xa1\xdc\xdc\xdc\xd8\x1e\xc3;777\xbc\x10(\xc2\x9aRd:\x9dr\'\x81W\x14E\x11\x1f\xb5\x95!X\x8a\x84a(\xb3\xd9\xcc\xf6\x18\xde\x98\xcdf\xbc\xbbR\x86\xb5\xa5\xccp8\x94\xe1ph{\x0c\xf5X\x8e:\x11,\x85\xe6\xf39\xef\x0c\xfe@\x18\x862\x9f\xcfm\x8f\x81\x17\xe0Y\xafP\xb7\xdbe\x83\xfb\x03\xf3\xf9\x9c\x8b\xca\x95"XJ\x8d\xc7c\xae}{\x01\x96\x9bn\x04K\xb1\xf9|\xce\xf5o\xbf!\x8ec\xde\x99*G\xb0\x14\x0b\xc3P\xee\xee\xee\xd8\x9f\xf5\x0bXV~`\xed)\x17\xc7\xb1|\xfa\xf4\x89KK~"\x08\x02\xf9\xf4\xe9\x13\xefF=@\xb0<\x90$\x89\xdc\xdd\xdd\xd9\x1e\xc3Ywww\xdcI\xd4\x13\x04\xcb\x13\xc3\xe1Pnoom\x8f\xe1\x9c\xdb\xdb[\xce\xb7\xf2\x08\xc1\xf2\xc8x<&Z_\xb8\xbd\xbd\xe5\x88\xa0g8\x19\xc53\xe3\xf1X:\x9d\x8e,\x97K1\xc6\xd8\x1e\xc7\x8a\xe7\x1d\xec\x83\xc1\xc0\xf6(xe\xbc\xc3\xf2\xd0`0\x90\xcf\x9f?\xb7\xf2\x88X\x18\x86\xf2\xf9\xf3gb\xe5\xa9\xf6=\xa3[\xa2\xd7\xeb\xc9_\x7f\xfd%\xbd^\xcf\xf6(W\xd3\xc6\x7fs\xdb\x04\x9b\xcd\xa6\xb1=\x04\xdeN\xd34\xb2^\xafe\xb7\xdb\xd9\x1e\xe5M\xdd\xdc\xdc\xc8l6\xe3\xf4\x0e\xcf\x11\xac\x96H\xd3T\x1e\x1e\x1e\xbc\xdb\xaf\x15\x86!G\x02[\x84`\xb5\x881F\xd6\xeb\xb5\xec\xf7{\xdb\xa3\xbc\x8a\xc9d\xc2=\xadZ\x86`\xb5P\x9e\xe7\xf2\xf8\xf8(eY\xda\x1e\xe5E\xe28\x96\x0f\x1f>p2h\x0b\x11\xac\x16\xdb\xef\xf7\xb2\xddn\xa5\xaa*\xdb\xa3\xfc\x92\xe7[\x1a\xf3\xa5\x11\xedE\xb0 \xc7\xe3Q\xb6\xdb\xad\x14Ea{\x94\xef\xea\xf5z2\x9dNe4\x1a\xd9\x1e\x05\x96\x11,\\\x9cN\'9\x1c\x0e\x92\xa6\xa94\x8d\xdd\xa7E\x10\x042\x1c\x0ee<\x1esN\x15.\x08\x16\xbea\x8c\x914Me\xbf\xdfK\x9e\xe7W\xfd\xbb\x93$\x91\xc9d"\xc3\xe1\x90\x9d\xe9\xf8\x06\xc1\xc2O\x19c$\xcfs9\x9dN\x92e\xd9\xab\xef\xa8\x8f\xe3X\xfa\xfd\xbe\x0c\x06\x03I\x92\x84H\xe1\xa7\x08\x16~\x8b1F\xaa\xaa\x92\xb2,\xe5|>_~\x1ac.\x8f\xe7\x8f\x93A\x10H\x18\x86\x97G\xb7\xdb\x958\x8e/?\xa3("P\xf8-\\\xfc\x8c\xdf\x12\x86\xa1\xf4z=.\x7f\x81\x15\xbc\xbc\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83\xef%\xc4\x0f5M#u]\xcb\xf9|\x96\xba\xae\xa5\xaek1\xc6|\xf5{\xd34b\x8c\x11\x11\xf9\xe6\xe7\xf3\x97\xa4~\xf9\xf3\xf9\xcbU;\x9d\x8et:\x9d\xaf~\xefv\xbb\xd2\xe9t$\x08\x02\x0b\xffZh@\xb0Z\xee\xcboo~~TUu\xf9\xdd\x86n\xb7+\xddnW\xa2(\xba\xfc\xfe\xe5\xb7F\xa3\xbdX\xfb-q>\x9f\xa5(\x8a\xcb\xd7\xcc??\x9e\xbfV\xde%\xcf\xb1\xcc\xf3\xfc\x9b\xff\x17\x04\x81\xc4q|yDQ$\xbd^\x8f\x90\xb5\x04k\xd9CUUI\x9e\xe7R\x96\xa5\xe4y.EQ8\x19\xa6\x97h\x9aF\x8a\xa2\x90\xa2(\xbe\xfa\xefA\x10H\xaf\xd7\x93$I$\x8ecI\x92D\xa2(\xb24%\xde\n\xc1R\xce\x18#Y\x96IQ\x14\x978=\xefCj\x93\xa6i$\xcf\xf3\xaf\xde\x95\x85ax\x89X\xaf\xd7\x93~\xbf\x7f\xd9\x9f\x06\x9d\x82\xcdf\xe3\xc7KoK\xd4u-y\x9eK\x96e\x97@\xe1\xd7=\x07\xac\xdf\xefK\x92$\xd2\xe9tl\x8f\x84\xdf@\xb0\x1c\xd74\x8ddYvy\x10\xa8\xd7\xf5\xfc\xce\xeb\xf9\xc1\x11J\xb7\x11,\x07\xd5u-\xa7\xd3I\xd24\x95\xd3\xe9\xe4\xcd\xfe\'\xd7\x05A \x83\xc1@\x86\xc3\xa1\x0c\x06\x03\xde}9\x88`9\xa2,\xcbK\xa4\xbewt\x0c\xd7\x97$\xc9%^q\x1c\xdb\x1e\x07B\xb0\xac\xaa\xaaJ\x8e\xc7\xa3\x1c\x0e\x07\xa9\xaa\xca\xf68\xf8\x89(\x8ad<\x1e\xcbh4\xe2\xe8\xa3E\x04\xeb\xca\x8c1\x97H\xf1NJ\xa7$I.\xf1\xe2\xa8\xe3u\x11\xac+h\x9aFN\xa7\x93\x1c\x0e\x07\xf6Iy\xe4y\x9f\xd7x<\x96\xc1`\xc0\x0e\xfb+ Xo\xe8|>\xcb~\xbf\x97\xfd~/u]\xdb\x1e\x07o\xa8\xd3\xe9\xc8d2\x91\xc9d\xc2Y\xf7o\x88`\xbd\x81\xa2(d\xb7\xdb\xc9\xf1x\xe4\xddT\xcb\x04A \xa3\xd1Hnnn\xa4\xd7\xeb\xd9\x1e\xc7;\x04\xeb\x15\xa5i*\xdb\xed\x96}S\x10\x91\x7f\xf6uM\xa7S\x19\x0e\x87\xb6G\xf1\x06\xc1z\x05\x87\xc3A6\x9b\rG\xfa\xf0]Q\x14\xc9\xbbw\xefd<\x1e\xdb\x1eE=\x82\xf5\x07\x8e\xc7\xa3<==\x11*\xfc\x92(\x8a\xe4\xfd\xfb\xf72\x1a\x8dl\x8f\xa2\x16\xc1z\x81\xd3\xe9$\xeb\xf5Z\xca\xb2\xb4=\n\x14\x8a\xe3Xf\xb3\x99\x0c\x06\x03\xdb\xa3\xa8C\xb0~C\x9e\xe7\xf2\xf4\xf4$Y\x96\xd9\x1e\x05\x1e\xe8\xf7\xfb\xf2\xfe\xfd{I\x92\xc4\xf6(j\x10\xac_`\x8c\x91\xf5z-\xfb\xfd\xde\xf6(\xf0\xd0d2\x91\xd9l\xc6I\xa8\xbf\x80`\xfd\x874Me\xb5ZY\xbb]0\xda\xa1\xdb\xed\xca|>\xe7\x88\xe2\x7f X?P\xd7\xb5\xacV+9\x1e\x8f\xb6GA\x8b\x8cF#\x99\xcf\xe7\xdc)\xe2\x07\x08\xd6w\x1c\x0e\x07Y\xadV\xad\xbcs\'\xec\x0b\xc3P\xe6\xf39\xa7A|\x07\xd7\x10\xfc\x9f\xd5j%\xbb\xdd\xce\xf6\x18h1c\x8c<<<HQ\x142\x9f\xcfm\x8f\xe3\x14\x82\xf5/c\x8c\xfc\xfd\xf7\xdf\x9c\xa5\x0eg\xecv;)\x8aB>}\xfa\xc4\x0e\xf9\x7f\xf1\x91P\xfe\xb9\xf6o\xb1X\xb0c\x1dN\xeav\xbb\xf2\xf1\xe3G\xaeM\x14\xbe\xaa^\xd24\x95\xfb\xfb{b\x05g\x9d\xcfg\xb9\xbf\xbf\x974Mm\x8fb]\xab\x83\xb5\xdb\xedd\xb1X\xb0s\x1d\xce3\xc6\xc8b\xb1h\xfd\xfe\xd5\xd6\x06k\xb7\xdb\xc9j\xb5\xb2=\x06\xf0[\xda~P\xa8\x95\xc1z>m\x01\xd0h\xb5Z\xc9\xe1p\xb0=\x86\x15\xad\x0bV\x96e\xf2\xf0\xf0`{\x0c\xe0\x8f<<<\xb4\xf2\x9a\xd6V\x05\xab,KY,\x16\xb6\xc7\x00^\xc5b\xb1h\xdd\x1dCZ\x13\xac\xa6id\xb9\\\xb2\x83\x1d\xde0\xc6\xc8r\xb9l\xd5m\xb8[\x13,\xee_\x05\x1f\x95e)\xeb\xf5\xda\xf6\x18W\xd3\x8a`eY\xd6\xea#+\xf0\xdbn\xb7k\xcd\xfe\xacV\x04\x8b#\x82\xf0][\x9e\xe3\xde\x07k\xb7\xdb\xf1Q\x10\xde+\xcb\xb2\x15\x9f"\xbc\x0eV\xd34\xb2\xd9ll\x8f\x01\\\xc5f\xb3\xf1~\x07\xbc\xd7\xc1:\x1e\x8f|\xe32Z\xa3\xaek\xefo8\xe9u\xb0\xda\xf0\x16\x19\xf8\x92\xef\xcfyo\x83U\x96\xa5\x14Ea{\x0c\xe0\xaa\x8a\xa2\xf0z\x9f\xad\xb7\xc1\xe2V\x1ch+\x9f\x9f\xfb\xde\x06\xebt:\xd9\x1e\x01\xb0\xc2\xe7\xe7\xbe\xb7\xc1\xe2\xe3 \xda\xca\xe7\xe7\xbe\x97\xc1\xaa\xeb\xda\xfb\xc3\xbb\xc0\x8f4M\xe3\xed\xd1qo\x83\x05\xb4\x99\xaf\xdb\x80\x97\xc1\x02\xe0\'/\x83\xc5-d\xd0v\xben\x03^\x06\x8b\xfdWh;_\xb7\x01/\x83\x15\x04\x81\xed\x11\x00\xab|\xdd\x06\xbc\x0c\x16\x00?\x11,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x04\x9b\xcd\xc6\xbb/03\xc6HY\x96\xb6\xc7\x00\xac\x89\xe3X\xc2\xd0\xbf\xf7#]\xdb\x03\xbc\x850\x0c%I\x12\xdbc\x00xe\xfe%\x18\x80\xb7\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\xfe\x07\xc7\x90\x82NM<\xd04\x00\x00\x00\x00IEND\xaeB`\x82'


# %% ../../nbs/classes/50_DomoUser.ipynb 31
domo_default_img = Image.from_bytestr(default_img_bytes)  


# %% ../../nbs/classes/50_DomoUser.ipynb 32
@patch_to(DomoUser)
async def upsert_avatar(
    self,
    avatar: Image,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    avatar.crop_square()

    res = "images are the same"
    if not are_same_image(domo_default_img, avatar):

        res = await user_routes.upload_avatar(
            auth=self.auth,
            user_id=self.id,
            img_bytestr=avatar.to_bytes(),
            img_type=avatar.format,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
            session=session,
        )

        if return_raw:
            return res

    await asyncio.sleep(2)

    return await self.download_avatar(debug_api=debug_api)

# %% ../../nbs/classes/50_DomoUser.ipynb 34
@patch_to(DomoUser)
async def toggle_direct_signon_access(self : DomoUser,
                                      is_enable_direct_signon : bool = True,
                                      session: httpx.AsyncClient = None,
                                      debug_api : bool =False,
                                      debug_num_stacks_to_drop : int= 2 ):
    
    res = await sso_routes.toggle_user_direct_signon_access(auth= self.auth,
        user_id_ls = [self.id],
        is_enable_direct_signon =is_enable_direct_signon,
        session = session,
        debug_api = debug_api,
        parent_class= self.__class__.__name__,
        debug_num_stacks_to_drop= debug_num_stacks_to_drop)
    
    return res

# %% ../../nbs/classes/50_DomoUser.ipynb 35
@patch_to(DomoUser)
async def get_api_clients(
    self,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    """
    retrieves Client_IDs for this user (assuming the authenticated user has manage rights).
    Note : the values will be masked, raw text values can only be retrieved via the UI
    """

    import domolibrary.classes.DomoInstanceConfig_ApiClient as dicli

    api_clients = dicli.ApiClients(auth=auth)
    domo_clients = await api_clients.get(
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop+1,
    )

    if return_raw: return res

    domo_clients = [
        domo_client
        for domo_client in domo_clients
        if domo_client.domo_user.id == self.id
    ]

    if not domo_clients:
        print(f"Domo User {self.id} - {self.display_name} does not have any Client_IDs")
        return False

    self.domo_api_clients = domo_clients

    return self.domo_api_clients

# %% ../../nbs/classes/50_DomoUser.ipynb 36
@patch_to(DomoUser)
async def get_access_tokens(
    self,
    debug_api: bool = False,
    debug_num_stacks_to_drop : int = 2,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoAccessToken as dmat

    domo_config = dmat.DomoAccessTokens(auth = self.auth)
    domo_tokens = await domo_config.get(
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop= debug_num_stacks_to_drop + 1
    )

    if return_raw:
        return domo_tokens
    
    domo_tokens = [domo_token for domo_token in domo_tokens if domo_token.owner.id == self.id]

    if not domo_tokens:
        print(f"Domo User {self.id} - {self.display_name} does not have any access tokens")
        return []
     
    self.domo_access_tokens = domo_tokens

    return self.domo_access_tokens

# %% ../../nbs/classes/50_DomoUser.ipynb 39
@dataclass
class DomoUsers:
    """a class for searching for Users"""

    auth: dmda.DomoAuth = field(repr=False)

    users: List[DomoUser] = None
    logger: Optional[lc.Logger] = None

    @classmethod
    def _users_to_domo_user(cls, user_ls, auth: dmda.DomoAuth):
        return [
            DomoUser._from_search_json(auth=auth, user_obj=user_obj)
            for user_obj in user_ls
        ]

    @classmethod
    def _users_to_virtual_user(cls, user_ls, auth: dmda.DomoAuth):
        return [
            DomoUser._from_virtual_json(auth=auth, user_obj=user_obj)
            for user_obj in user_ls
        ]

    def _generate_logger(self, logger: Optional[lc.Logger] = None):
        self.logger = logger or self.logger or lc.Logger(app_name="domo_users")

    @staticmethod
    def _util_match_domo_users_to_emails(
        domo_users: list[DomoUser], user_email_ls: list[str]
    ) -> list:
        """pass in an array of user emails to match against an array of Domo User"""

        return [
            domo_user
            for domo_user in domo_users
            if domo_user.email_address.lower() in [email.lower() for email in user_email_ls]
        ]

    @staticmethod
    def _util_match_users_obj_to_emails(
        user_ls: list[dict], user_email_ls: list[str]
    ) -> list:
        """pass in an array of user emails to match against an array of Domo User"""

        return [
            obj
            for obj in user_ls
            if obj.get("emailAddress").lower() in [email.lower() for email in user_email_ls]
        ]


# %% ../../nbs/classes/50_DomoUser.ipynb 41
@patch_to(DomoUsers)
async def get(
    self,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session : httpx.AsyncClient = None,
) -> List[DomoUser]:
    """retrieves all users from Domo"""

    res = await user_routes.get_all_users(
        auth=self.auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        session = session
    )

    if return_raw:
        return res

    self.users = self._users_to_domo_user(user_ls=res.response, auth=self.auth)
    return self.users

@patch_to(DomoUsers, cls_method=True)
async def all_users(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session : httpx.AsyncClient = None,
    logger: Optional[lc.Logger] = None,
) -> List[DomoUser]:
    """retrieves all users from Domo"""

    res = await user_routes.get_all_users(
        auth=auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
        session = session
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    users_ls = res.response

    return cls._users_to_domo_user(user_ls=users_ls, auth=auth)

# %% ../../nbs/classes/50_DomoUser.ipynb 43
class DomoUser_NoSearch(dmde.ClassError):
    def __init__(self, message : str, domo_instance , cls_instance = None, cls = None):
        super().__init__(cls= cls, cls_instance=cls_instance, message = message,
                         entity_id = domo_instance
                         )

# %% ../../nbs/classes/50_DomoUser.ipynb 44
@patch_to(DomoUsers)
async def search_by_email(
    self,
    email: Union[str, list],
    only_allow_one: bool = True,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
    suppress_no_results_error: bool = False,
    session: httpx.AsyncClient = None,
) -> list:

    emails = [email] if isinstance(email, str) else email

    try:
        res = await user_routes.search_users_by_email(
            user_email_ls=emails,
            auth=self.auth,
            return_raw=return_raw,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=self.__class__.__name__,
            session=session,
        )

    except SearchUser_NoResults as e:
        if suppress_no_results_error:
            return None

        raise e from e

    if return_raw:
        return res

    domo_users = self._users_to_domo_user(res.response, auth=self.auth)

    if not only_allow_one:
        return domo_users

    domo_users = self._util_match_domo_users_to_emails(domo_users, emails)

    if not domo_users:
        raise DomoUser_NoSearch(
            cls_instance=self, message=f'unable to find {",".join(emails)}',
            domo_instance = self.auth.domo_instance
        )

    return domo_users[0]


@patch_to(DomoUsers, cls_method=True)
async def by_email(
    cls: DomoUsers,
    email_ls: list[str],
    auth: dmda.DomoAuth,
    only_allow_one: bool = True,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
    suppress_no_results_error: bool = False,
    session: httpx.AsyncClient = None,
) -> list:

    try:
        res = await user_routes.search_users_by_email(
            user_email_ls=email_ls,
            auth=auth,
            return_raw=False,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=cls.__name__,
            session=session,
        )
    except SearchUser_NoResults as e:
        if suppress_no_results_error:
            return None

        raise e

    if return_raw:
        return res

    domo_users = cls._users_to_domo_user(res.response, auth=auth)

    if not only_allow_one:
        return domo_users

    domo_users = cls._util_match_domo_users_to_emails(domo_users, email_ls)

    if not domo_users:
        raise DomoUser_NoSearch(cls=cls, message=f'unable to find {",".join(email_ls)}', domo_instance = auth.domo_instance)

    return domo_users[0]

@patch_to(DomoUsers, cls_method=True)
async def by_id(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    user_ids: list[str],  # can search for one or multiple users
    suppress_no_results_error: bool = False,
    only_allow_one: bool = True,
    debug_num_stacks_to_drop=2,
    debug_api: bool = False,
    return_raw: bool = False,
    session : httpx.AsyncClient = None
) -> Union[List[DomoUser], DomoUser, ResponseGetData, bool]:
    
    res = None

    try:
        res = await user_routes.search_users_by_id(
            return_raw=return_raw,
            user_ids=user_ids,
            debug_api=debug_api,
            auth=auth,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=cls.__name__,
            session = session
        )

    except SearchUser_NoResults as e:
        if suppress_no_results_error:
            print(e)

            if only_allow_one:
                return False
            return []

        raise e from e

    if return_raw:
        return res

    domo_users = cls._users_to_domo_user(user_ls=res.response, auth=auth)

    if only_allow_one:
        return domo_users[0]

    return domo_users

# %% ../../nbs/classes/50_DomoUser.ipynb 47
@patch_to(DomoUsers, cls_method=True)
async def virtual_user_by_subscriber_instance(
    cls: DomoUsers,
    subscriber_instance_ls: str,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
):
    res = await user_routes.search_virtual_user_by_subscriber_instance(
        auth=auth,
        subscriber_instance_ls=subscriber_instance_ls,
        debug_api=debug_api,
    )

    if return_raw:
        return res


    domo_users = cls._users_to_virtual_user(res.response, auth=auth)
    return domo_users

# %% ../../nbs/classes/50_DomoUser.ipynb 50
@patch_to(DomoUsers, cls_method=True)
async def create_user(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    display_name,
    email_address,
    role_id,
    password: str = None,
    send_password_reset_email: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    """class method that creates a new Domo user"""

    res = await user_routes.create_user(
        auth=auth,
        display_name=display_name,
        email_address=email_address,
        role_id=role_id,
        debug_api=debug_api,
        session=session,
    )

    domo_user = await DomoUser.get_by_id(
        auth=auth,
        user_id=res.response.get("id") or res.response.get("userId"),
    )

    if password:
        await domo_user.reset_password(new_password=password)

    elif send_password_reset_email:
        await domo_user.request_password_reset(
            domo_instance=auth.domo_instance, email=domo_user.email_address
        )

    return domo_user

# %% ../../nbs/classes/50_DomoUser.ipynb 52
@patch_to(DomoUsers)
async def upsert(
    self: DomoUsers,
    email_address: str,
    display_name: str = None,
    role_id: str = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 2,
    session: httpx.AsyncClient = None,
):
    test_valid_email(email_address)

    try:
        domo_user = await self.search_by_email(
            email = email_address,
            only_allow_one=True,
            debug_api=debug_api,
            session = session, 
            debug_num_stacks_to_drop = debug_num_stacks_to_drop + 1
        )

        if domo_user:
            user_property_ls = []
            if display_name:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.display_name, display_name
                    )
                )

            if role_id:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.role_id, role_id
                    )
                )

            if user_property_ls:
                await user_routes.update_user(
                    user_id=domo_user.id,
                    user_property_ls=user_property_ls,
                    auth=self.auth,
                    debug_api=debug_api,
                )
        return await DomoUser.get_by_id(auth=self.auth, user_id=domo_user.id)

    except (SearchUser_NoResults, DomoUser_NoSearch) as e:

        if not role_id:
            raise CreateUser_MissingRole(
                domo_instance=self.auth.domo_instance, email_address=email_address
            ) from e

        domo_user = await DomoUser.create(
            display_name=display_name or f"{email_address} - via dl {dt.date.today()}",
            email_address=email_address,
            role_id=role_id,
            debug_api=debug_api,
            session=session,
            auth = self.auth
        )

        await self.get()

        return domo_user

    # finally:
    #     if grant_ls:
    #         grant_ls = domo_role._valid_grant_ls(grant_ls)
    #         await domo_role.set_grants(grant_ls=grant_ls)

@patch_to(DomoUsers, cls_method=True)
async def upsert_user(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    email_address: str,
    display_name: str = None,
    role_id: str = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    test_valid_email(email_address)

    try:
        domo_user = await cls.by_email(
            email_ls=[email_address],
            auth=auth,
            only_allow_one=True,
            debug_api=debug_api,
        )

        if domo_user:
            user_property_ls = []
            if display_name:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.display_name, display_name
                    )
                )

            if role_id:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.role_id, role_id
                    )
                )

            if user_property_ls:
                await user_routes.update_user(
                    user_id=domo_user.id,
                    user_property_ls=user_property_ls,
                    auth=auth,
                    debug_api=debug_api,
                )
        return await DomoUser.get_by_id(auth=auth, user_id=domo_user.id)

    except (SearchUser_NoResults,DomoUser_NoSearch) as e:
        if debug_prn:
            print(f"No user match -- creating new user in {auth.domo_instance}")

        if not role_id:
            raise CreateUser_MissingRole(
                domo_instance=auth.domo_instance, email_address=email_address
            ) from e

        return await cls.create_user(
            auth=auth,
            display_name=display_name or f"{email_address} - via dl {dt.date.today()}",
            email_address=email_address,
            role_id=role_id,
            debug_api=debug_api,
            session=session,
        )

    # finally:
    #     if grant_ls:
    #         grant_ls = domo_role._valid_grant_ls(grant_ls)
    #         await domo_role.set_grants(grant_ls=grant_ls)
